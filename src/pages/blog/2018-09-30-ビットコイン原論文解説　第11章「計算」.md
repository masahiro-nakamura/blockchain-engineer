---
templateKey: blog-post
title: ビットコイン原論文解説　第11章「計算」
date: 2018-09-30T08:28:10.434Z
description: ビットコイン原論文の第11章「計算」について分かりやすく解説します。
tags:
  - ビットコイン
  - 解説
---
![Bitcoin](/img/bitcoin-header.jpg)

## 目次

概要

第1章　イントロダクション

第2章　取引

第3章　タイムスタンプ・サーバー

第4章　Proof of Work

第5章　ネットワーク

第6章　インセンティブ

第7章　ディスク領域の再利用

第8章　簡易版支払い検証

第9章　価値の結合と分割

第10章　プライバシー

**<font color="Green">第11章　計算</font>**

第12章　結論

## 原文

> We consider the scenario of an attacker trying to generate an alternate chain faster than the honest chain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such as creating value out of thin air or taking money that never belonged to the attacker. Nodes are not going to accept an invalid transaction as payment, and honest nodes will never accept a block containing them. An attacker can only try to change one of his own transactions to take back money he recently spent.
>
> The race between the honest chain and an attacker chain can be characterized as a Binomial Random Walk. The success event is the honest chain being extended by one block, increasing its lead by +1, and the failure event is the attacker's chain being extended by one block, reducing the gap by -1.
>
> The probability of an attacker catching up from a given deficit is analogous to a Gambler's Ruin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an infinite number of trials to try to reach breakeven. We can calculate the probability he ever reaches breakeven, or that an attacker ever catches up with the honest chain, as follows \[8]:
>
> * p = probability an honest node finds the next block
> * q = probability the attacker finds the next block
> * qz = probability the attacker will ever catch up from z blocks behind
>
> ![Formula](/img/bitcoin_calc_1_pdf.png)
>
> Given our assumption that p > q, the probability drops exponentially as the number of blocks the attacker has to catch up with increases. With the odds against him, if he doesn't make a lucky lunge forward early on, his chances become vanishingly small as he falls further behind.
>
> We now consider how long the recipient of a new transaction needs to wait before being sufficiently certain the sender can't change the transaction. We assume the sender is an attacker who wants to make the recipient believe he paid him for a while, then switch it to pay back to himself after some time has passed. The receiver will be alerted when that happens, but the sender hopes it will be too late.
>
> The receiver generates a new key pair and gives the public key to the sender shortly before signing. This prevents the sender from preparing a chain of blocks ahead of time by working on it continuously until he is lucky enough to get far enough ahead, then executing the transaction at that moment. Once the transaction is sent, the dishonest sender starts working in secret on a parallel chain containing an alternate version of his transaction.
>
> The recipient waits until the transaction has been added to a block and z blocks have been linked after it. He doesn't know the exact amount of progress the attacker has made, but assuming the honest blocks took the average expected time per block, the attacker's potential progress will be a Poisson distribution with expected value:
>
> ![Formula2](/img/bitcoin_calc_2_pdf.png)
>
> To get the probability the attacker could still catch up now, we multiply the Poisson density for each amount of progress he could have made by the probability he could catch up from that point:
>
> ![Formula3](/img/bitcoin_calc_3_pdf.png)
>
> Rearranging to avoid summing the infinite tail of the distribution...
>
> ![Formula4](/img/bitcoin_calc_4_pdf.png)
>
> Converting to C code...

```
#include <math.h>
double AttackerSuccessProbability(double q, int z)
{
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k = 0; k <= z; k++)
    {
        double poisson = exp(-lambda);
        for (i = 1; i <= k; i++)
        poisson *= lambda / i;
        sum -= poisson * (1 - pow(q / p, z - k));
    }
    return sum;
}
```

> Running some results, we can see the probability drop off exponentially with z.
>
> * q=0.1
>   * z=0　　P=1.0000000
>   * z=1　　P=0.2045873
>   * z=2　　P=0.0509779
>   * z=3　　P=0.0131722
>   * z=4　　P=0.0034552
>   * z=5　　P=0.0009137
>   * z=6　　P=0.0002428
>   * z=7　　P=0.0000647
>   * z=8　　P=0.0000173
>   * z=9　　P=0.0000046
>   * z=10　　P=0.0000012
> * q=0.3
>   * z=0　　 P=1.0000000
>   * z=5　　 P=0.1773523
>   * z=10　　P=0.0416605
>   * z=15　　P=0.0101008
>   * z=20　　P=0.0024804
>   * z=25　　P=0.0006132
>   * z=30　　P=0.0001522
>   * z=35　　P=0.0000379
>   * z=40　　P=0.0000095
>   * z=45　　P=0.0000024
>   * z=50　　P=0.0000006
>
> Solving for P less than 0.1%...
>
> * P < 0.001
>   * q=0.10　　z=5
>   * q=0.15　　z=8
>   * q=0.20　　z=11
>   * q=0.25　　z=15
>   * q=0.30　　z=24
>   * q=0.35　　z=41
>   * q=0.40　　z=89
>   * q=0.45　　z=340

## 原文日本語訳

善意のノードによるチェーンよりも速く代替チェーンを生成しようとする攻撃者のシナリオを考えてみます。仮にこれが達成されたとしても、無からコインを生み出したり、攻撃者のものではないコインを奪うといった、任意の変更をシステムに与えることはありません。ノードは無効なトランザクションを支払いとして受け入れず、善意のノードはそれらを含むブロックを決して受け入れません。攻撃者ができることは、攻撃者が支払った直近のお金を取り戻そうと、自身のトランザクションを変更しようと試みるだけです。

善良なチェーンと攻撃者のチェーンの間の競争は、「二項ランダムウォーク」として特徴付けることができます。 成功イベントでは、善良なチェーンが1ブロック拡張され、そのリードが1増加します。失敗イベントでは、攻撃者のチェーンが1ブロック拡張され、善良なチェーンとの差が1減少します。

攻撃者が所与のビハインドから追いつく可能性は「ギャンブラー破産問題」に類似しています。無限の資金を持つギャンブラーが赤字からスタートし、損益分岐点を目指して無限回の賭けを行うと仮定しましょう。この時、ギャンブラーが損益分岐点にたどり着く確率、あるいは攻撃者が善良なチェーンに追いつく確率は次のように計算できます。

* p = 善良なノードが次のブロックを見つける確率
* q = 攻撃者が次のブロックを見つける確率
* qz = 攻撃者が zブロックのビハインドを追いつく確率

![Formula](/img/bitcoin_calc_1_pdf.png)

p > q と仮定すると、攻撃者が追いつく確率は、追いつかなければいけないブロック数に応じて指数関数的に下がります。もし攻撃者が幸運に恵まれないならば、攻撃者の勝ち目とともに、攻撃者のチャンスはビハインドを受けるごとに小さく消えていきます。

ここで、新しいトランザクションの受信者が、送信者がトランザクションを変更できないことを十分に確信するまで、どのくらいの時間を待つ必要があるか検討してみましょう。送信者が、しばらくの間受信者に支払いを行なったと信じ込ませ、その後ある程度時間が経ったらその支払いを送信者自身に戻すべくトランザクションを切り替えようとする攻撃者であると仮定してみます。切り替えが起こると受信者には警告が届きますが、送信者は警告が手遅れであることを期待します。

受信者は新しいキーペアを生成し、署名の直前に公開鍵を送信者に与えます。これを続けることで、送信者が幸運に恵まれてその瞬間にトランザクションを実行するまで、送信者があらかじめブロックチェーンを用意することをできなくします。トランザクションが送信されると、不正な送信者は、送信したトランザクションの代替バージョンを含むパラレルチェーン上で秘密裡に作業を開始します。

受信者は、トランザクションがブロックに追加され、その後にzブロックがリンクされるまで待機します。受信者は攻撃者がどの程度ブロックを拡張したか正確に把握していませんが、善良なブロックが平均ブロック作成時間であったと仮定すると、攻撃者の潜在的な拡張は期待値のポアソン分布になります。

![Formula2](/img/bitcoin_calc_2_pdf.png)

攻撃者がその時点でも追いつく可能性のある確率を得るために、攻撃者がその時点から追いつく可能性のある進捗の量ごとにポアソン密度を掛けます：

![Formula3](/img/bitcoin_calc_3_pdf.png)

分布の無限の項を合計するのを避けるために整理すると、

![Formula4](/img/bitcoin_calc_4_pdf.png)

以上をC言語に直すと、

```
#include <math.h>
double AttackerSuccessProbability(double q, int z)
{
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k = 0; k <= z; k++)
    {
        double poisson = exp(-lambda);
        for (i = 1; i <= k; i++)
        poisson *= lambda / i;
        sum -= poisson * (1 - pow(q / p, z - k));
    }
    return sum;
}
```

いくつかの結果を実行すると、確率はzが増すごとに指数関数的に低下することがわかります。

* q=0.1
  * z=0　　P=1.0000000
  * z=1　　P=0.2045873
  * z=2　　P=0.0509779
  * z=3　　P=0.0131722
  * z=4　　P=0.0034552
  * z=5　　P=0.0009137
  * z=6　　P=0.0002428
  * z=7　　P=0.0000647
  * z=8　　P=0.0000173
  * z=9　　P=0.0000046
  * z=10　　P=0.0000012
* q=0.3
  * z=0　　 P=1.0000000
  * z=5　　 P=0.1773523
  * z=10　　P=0.0416605
  * z=15　　P=0.0101008
  * z=20　　P=0.0024804
  * z=25　　P=0.0006132
  * z=30　　P=0.0001522
  * z=35　　P=0.0000379
  * z=40　　P=0.0000095
  * z=45　　P=0.0000024
  * z=50　　P=0.0000006

Pを0.1％未満として解くと、

* P < 0.001
  * q=0.10　　z=5
  * q=0.15　　z=8
  * q=0.20　　z=11
  * q=0.25　　z=15
  * q=0.30　　z=24
  * q=0.35　　z=41
  * q=0.40　　z=89
  * q=0.45　　z=340

## 解説

### まとめ

* 善意なノードと攻撃者の間のブロックチェーン拡張競争では、善良なノードが攻撃者よりも次のブロックを見つける可能性が高い時、攻撃者がビハインドを追いつく可能性は指数関数的に下がる。
* 新しいトランザクションの受信者は、ブロックが作成されればされるほど、攻撃者によってトランザクションを改ざんされないと十分に確信を得ることができる。

### 詳しい解説

<hr>
＜　前章: 第10章　プライバシー

　　次章: 第12章　結論　＞
