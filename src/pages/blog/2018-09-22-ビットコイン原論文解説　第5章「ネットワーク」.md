---
templateKey: blog-post
title: ビットコイン原論文解説　第5章「ネットワーク」
date: 2018-09-22T05:34:53.301Z
description: ビットコイン原論文の第5章「ネットワーク」について分かりやすく解説します。
tags:
  - ビットコイン
  - 解説
---
![Bitcoin](/img/bitcoin-header.jpg)

## 目次

概要

第1章　イントロダクション

第2章　取引

第3章　タイムスタンプ・サーバー

第4章　Proof of Work

**<font color="Green">第5章　ネットワーク</font>**

第6章　インセンティブ

第7章　ディスク領域の再利用

第8章　簡易版支払い検証

第9章　価値の結合と分割

第10章　プライバシー

第11章　計算

第12章　結論

## 原文

> The steps to run the network are as follows:
>
> 1. New transactions are broadcast to all nodes.
> 2. Each node collects new transactions into a block.
> 3. Each node works on finding a difficult proof-of-work for its block.
> 4. When a node finds a proof-of-work, it broadcasts the block to all nodes.
> 5. Nodes accept the block only if all transactions in it are valid and not already spent.
> 6. Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.
>
> Nodes always consider the longest chain to be the correct one and will keep working on extending it. If two nodes broadcast different versions of the next block simultaneously, some nodes may receive one or the other first. In that case, they work on the first one they received, but save the other branch in case it becomes longer. The tie will be broken when the next proofof-work is found and one branch becomes longer; the nodes that were working on the other branch will then switch to the longer one.
>
> New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one.

## 原文日本語訳

ネットワークを実行する手順は次のとおりです。

1. 新しい取引はすべてのノードにブロードキャストされます。
2. 各ノードは新しい取引をブロックに集めます。
3. 各ノードは、そのブロックに対して困難なProof of Workに取り組みます。
4. ノードがProof of Workを完了すると、すべてのノードにブロックをブロードキャストします。
5. ノードは、その中のすべての取引が有効で、二重取引されていない場合にのみブロックを受け入れます。
6. ノードは、受領したブロックのハッシュを前のハッシュとして使用して次のブロックの作成に取り組むことで、ブロックの受け入れを表します。

ノードは常に最長のチェーンを正しいものと見なし、拡張を続けます。2つのノードが異なるブロックを同時にブロードキャストする場合、ノードはどちらかのブロックを先に受け取ります。その場合、彼らは最初に受け取ったものを正しいとみなして処理を進めますが、もう一方のブランチが長くなることに備えて後から届いたブロックも保持します。次のProof of Work完了して1つのブランチが長くなると均衡は崩れます。短い方のブランチで作業していたノードは、長いブランチに切り替えます。

新しい取引がブロードキャストされても、必ずしもすべてのノードに到達する必要はありません。取引が多くのノードに到達する限り、遠からずブロックに入るでしょう。ブロックのブロードキャストもまた、メッセージが脱落したとしても寛容です。もしノードがブロックを受信しなかった場合、ノードは次のブロックを受信したとき、あるいはブロックが失われていると認識したときにブロックを要求します。

## 解説

### まとめ

* 新しい取引記録は全てのノードにブロードキャストされ、ブロックにまとめられ、Proof of Workが完了するとブロックがブロードキャストされる。
* ノードは親ブロックのハッシュを子ブロックに入れ込むことで、ブロックの受け入れを表明する。
* ノードは最長のチェーンを正しいものとみなして拡張を行う。
* もし同時に新しいブロックが作られて、ノードが異なる二つを受け取ったら、先に届いた方のブランチでチェーンを伸ばす。その後、もう一方のブランチが長くなるならば、長い方のブランチに切り替える。
* 取引もブロックも将来的には全ノードに行き渡るので、瞬時に全ノードに取り込まれる必要はない。

### 詳しい解説

本章はネットワークの中でブロックチェーンがどういう順番で作成されていくのかを、ノードの目線で解説しています。ブランチの下りなどはGitユーザーにとってはイメージしやすいものではないでしょうか。もちろんGitを利用したことがない方にもわかりやすく説明します。

ノードの役割

まず、ノードの役割を整理してみます。

1. ブロックチェーンを保存する
2. Proof of Workを解いて新しいブロックを生成する
3. 取引やブロックに問題がないか検証する

1番目の役割があることで、これまでの取引記録を遡って追跡が可能になります。始まりから全てのデータを持っているノードのことを「フルノード」と呼びます。一般ユーザー、あるいはウォレットなどを開発する事業者の一部は、フルノードが用意するサーバーを通してブロックチェーンにアクセスします。もちろん、そのような事業者が介在することは中央を作ることと同じですので、自らフルノードになっても構いません。その場合には全てのデータが保存できるだけのストレージ、24時間のネット接続環境、検証するのに十分なメモリを備える必要があります。

2番目の役割ですが、前章で解説した通り、Proof of Workの計算は膨大なCPUパワーを消費し、高性能なマシン代や高額な電気代といったコストがかかります。なぜそのようなコストをかけてまでネットワークを維持するかという理由は、次章の「インセンティブ」で解説します。なお、Proof of Workを行ってブロックを生成することを「マイニング（採掘）」と呼ぶので、そのようなノードを一般に「マイナー（採掘者）」と呼びます。このマイナー達のおかげでブロックが作られ、取引が承認されるので、自らマイナーとならなくても取引を行うことができます。

3番目の役割は取引やブロックの検証です。取引については第2章で二重支払い問題について取り上げていましたが、二重支払いだけでなく、様々な送金に関するルールを満たしているかがチェックされます。ブロックの検証も同様に、Proof of Workで定められた条件を満たしたノンスであるかだけでなく、様々なブロック生成のルールに準拠しているかがチェックされます。この検証ができるノードはフルノードだけでなく、ブロックチェーンデータの一部だけを持てば良い、より軽量なノードでも簡易的に実施することができます。詳細は第8章「簡易版支払い検証」で解説します。

これらが主な役割ですが、他にも受け取った取引やブロックを、隣接するノードに伝播させるという重要な役割も担っています。

ブロックのコンフリクト

当然のことながら、世界中にノードがあるので新しい取引やブロックが伝播するのは時間がかかります。このタイムラグは数秒程度と言われていますが、その数秒の間に異なるノードが異なるブロックを同時に作成し、ネットワークに流してしまうことがありえます。

ブロックを受け取るノードは、先に届いた方のブロックを検証してチェーンに加えます。そして、新しいブロックをそのチェーンに加えるようにProof of Workを実行します。

ではこの時、後から遅れて届いたブロックを無視するかというと、そうはしません。遅いブロックについてもサブブランチとして取り込んでおきます。そしてその後、サブブランチの方をメインブランチとして扱っていたノードから新しいブロックが届いたならばい、サブブランチをメインブランチに切り替えます。これがブロックチェーンの「再収縮（reconvergence）」と呼ばれる現象です。





<hr>
次章: 第6章　インセンティブ
